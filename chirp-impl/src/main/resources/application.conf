play.akka.actor-system = "chirpservice"
play.modules.enabled += sample.chirper.chirp.impl.ChirpModule
play.modules.enabled += com.lightbend.rp.servicediscovery.lagom.javadsl.ServiceLocatorModule

db {
  # You can declare as many datasources as you want.
  # By convention, the default datasource is named `default`
  default {
    driver = "org.postgresql.Driver"
    url = "jdbc:postgresql://"${?POSTGRES_HOST}":"${?POSTGRES_PORT}"/"${?POSTGRES_DB}
    username = ${?POSTGRES_USER}
    password = ${?POSTGRES_PASSWORD}
    # You can turn on SQL logging for any datasource
    # https://www.playframework.com/documentation/latest/Highlights25#Logging-SQL-statements
    logSql = true
  }
}

jdbc-defaults.slick.profile = "slick.jdbc.PostgresProfile$"

# Enable the serializer provided in Akka 2.5.8+ for akka.Done and other internal
# messages to avoid the use of Java serialization.
akka.actor.serialization-bindings {
  "akka.Done"                 = akka-misc
  "akka.actor.Address"        = akka-misc
  "akka.remote.UniqueAddress" = akka-misc
}


play.http.secret.key=${?APPLICATION_SECRET}

akka.cluster {
  # Defines how the coordinator stores its state. Same is also used by the
  # shards for rememberEntities.
  # Valid values are "ddata" or "persistence".
  sharding.state-store-mode = ${?AKKA_CLUSTER_SHARDING_STATE_STORE_MODE}

  roles = [${?AKKA_CLUSTER_ROLE}]
}

lagom {
  cluster {
    # The cluster node will join itself if akka.cluster.seed-nodes is not configured.
    # In dev-mode this setting will be on, otherwise the default is off. It's possible
    # to override that by defining akka.cluster.seed-nodes or set this property to off in
    # the application.conf
    join-self = ${?LAGOM_CLUSTER_JOIN_SELF}

    # Exit the JVM forcefully when the ActorSystem has been terminated after
    # removing the cluster membership (other causes of actor system termination
    # will not trigger a JVM exit).
    # This is by default off, but it should be turned on in production so the
    # process restarts.
    # The recommended value (depending on the environment) is:
    #    * development mode : off
    #    * running tests : off
    #    * production / staging  : on
    exit-jvm-when-system-terminated = on
  }

  persistence {
    # A persistent entity is passivated automatically if it does not receive
    # any messages during this timeout. Passivation is performed to reduce
    # memory consumption. Objects referenced by the entity can be garbage
    # collected after passivation. Next message will activate the entity
    # again, which will recover its state from persistent storage. Set to 0
    # to disable passivation - this should only be done when the number of
    # entities is bounded and their state, sharded across the cluster, will
    # fit in memory.
    passivate-after-idle-timeout = ${?LAGOM_PERSISTENCE_PASSIVATE_AFTER_IDLE_TIMEOUT}

    # Specifies that the read side processors should run on cluster nodes with a specific role.
    # If the role is not specified (or empty) all nodes in the cluster are used.
    read-side.run-on-role = ${?LAGOM_READ_SIDE_RUN_ON_ROLE}
  }
}
